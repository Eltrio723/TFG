
\subsection{Iteración 1}

El objetivo inicial de esta entrega era el de diseñar y crear todo el flujo que seguirá el juego. Teniendo en cuenta de que se pretende recrear un concurso televisivo, se va desarrollar una introducción que describa el concurso y presente las reglas al jugador, además de las fases que ocurrirán al principio y final de cada prueba, así como entre cada una de ellas. Finalmente, se añadirá un menú en el que se podrán cambiar los ajustes del juego, entre ellos: la dificultad, los tipos de pruebas que aparecerán, si el jugador está sentado o de pie, o si el jugador tendrá ayuda de una persona externa o no.

Este objetivo se ha visto alterado por pasar a disponer de un nuevo dispositivo de RV para el desarrollo, en este caso las gafas Meta Quest 2. Como se explica en la sección \textbf{Tecnología a usar} (\ref{sec:tecnologiaUsar}), este dispositivo es mucho más deseable para este proyecto, ya que permite prescindir de un ordenador externo al que conectar las gafas, del uso de estaciones base separadas para realizar el seguimiento del casco y los mandos, y al ser más reciente permite utilizar las bibliotecas más modernas para facilitar el desarrollo. Por estas razones, aún suponiendo un extra de carga de trabajo, se decide realizar el cambio de dispositivo, el cual se describe a continuación.


\subsubsection{Migración dispositivo VR}

El primer paso es crear una copia de seguridad en caso de haber alguna incompatibilidad. A continuación, se descarga la última versión del editor de Unity, en este caso se usará la versión 2023.1.9f1. Una vez instalada, abrimos el proyecto usando la nueva versión. Durante la migración de una versión a otra aparecen errores de y se recibe el aviso de que el proyecto puede no funcionar. Cuando se abre el proyecto aparece un nuevo aviso sobre varios paquetes que están obsoletos (\ref{fig:deprecated})




\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/03.deprecated.png}
	\caption{Aviso sobre paquetes obsoletos.}
	\label{fig:deprecated}
\end{figure}


Tras desinstalar los paquetes obsoletos, en este caso tanto SteamVR, Zinnia y VRTK, se va a proceder a instalar las nuevas bibliotecas para Meta Quest 2, para ello se va a seguir la documentación oficial. \cite{DES_5_1_oculusSDK} El proceso a seguir es sencillo y consiste en importar el nuevo paquete OculusIntegration (versión 55 en este caso). No ha surgido ningún nuevo problema, la documentación es buena y muy visual, y un proceso similar ya se ha descrito en la \textbf{Entrega 1} (\ref{sec:Entrega1Iteracion1}), por lo que no voy a desarrollar mucho esta instalación.

Una vez instalada la nueva biblioteca, el siguiente paso es recuperar todas las funcionalidades que ya estaban desarrolladas para las HTC Vive anteriormente. Por suerte el SDK de integración de Oculus es muy completo y tiene ya implementado casi todo lo necesario. Usando el objeto OculusInteractionSampleRig (figura \ref{fig:sample_rig}), podemos añadir a la escena tanto la cámara como los controladores y todo lo necesario para el seguimiento y la interacción básica con el juego.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/04.sample_rig.png}
	\caption{Jerarquía del objeto OculusInteractionSampleRig incluido con el SDK de Meta.}
	\label{fig:sample_rig}
\end{figure}


Para facilitar el uso del juego a personas con pocos conocimientos tecnológicos, se va a usar el seguimiento de manos proporcionado por el visor, de esta forma se proyecta en el juego una representación exacta de las manos de los usuarios y sus movimientos, como se puede ver en la figura \ref{fig:hand_tracking}.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/05.hand_tracking.png}
	\caption{Manos virtuales captadas usando el seguimiento de Meta Quest 2.}
	\label{fig:hand_tracking}
\end{figure}

A continuación es necesario añadir las posibles interacciones de las manos con el entorno, en este caso: coger y pulsar objetos y poder seleccionar elementos lejanos mediante un rayo. De nuevo, el SDK proporciona elementos ya configurados para estos casos. Solo es necesario añadirlos a la jerarquía según la figura \ref{fig:interactors}. En este caso se añaden tanto para las manos como para los mandos, en caso de desear utilizarlos.


\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/06.interactors.png}
	\caption{\textit{Interactors} que permiten coger, pulsar o lanzar rayos.}
	\label{fig:interactors}
\end{figure}

Finalmente, para que un objeto del juego pueda interactuar con el jugador, necesita nuevos scripts también proporcionados por el SDK, en este caso son: 

♠\begin{itemize}
	\item {\textit{Grabbable}: Permite que un objeto pueda ser cogido y define su comportamiento.}
	\item{\textit{Grab Interactable}: Permite que el elemento sea cogido con los mandos.}
	\item{\textit{Hand Grab Interactable}: Permite que el elemento sea cogido con las manos.}
	\item{\textit{Ray Interactable}: Permite lanzar un rayo sobre el objeto para interactuar con él.}
\end{itemize}


Tras estos pasos, la migración queda terminada y podemos comenzar a utilizar Meta Quest 2 y su seguimiento de manos en el proyecto. Aunque aún es necesario cambiar el funcionamiento de varias pruebas debido a cambios en las nuevas bibliotecas.


En concreto es necesario actualizar las zonas de \textit{snap} utilizadas en las pruebas de asociación, donde el jugador debe coger y colocar en plataformas distintos objetos, agrupándolos por categorías. Lo que se ha decidido hacer es reemplazar este sistema por otro más sencillo en el que un \textit{trigger} sobre la plataforma detecta los objetos que se introducen en él (figura \ref{fig:detectZone}), comprobando si tienen o no la categoría deseada. 


\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/07.detect_zone.png}
	\caption{Zona de detección formada por un \textit{trigger} sobre una plataforma.}
	\label{fig:detectZone}
\end{figure}

Puesto que se usa el mismo método de detección para las dos posibles categorías, es necesario tener en cuenta de qué categoría es el objeto y si las dos zonas de detección contienen el mismo tipo de objeto. Esto se hace por medio de los métodos \textit{OnTriggerEnter} y \textit{OnTriggerExit}. También es necesario llevar la cuenta de cuantos objetos hay dentro del \textit{trigger}. Todo esto se hace como se muestra en la figura \ref{fig:detectZoneCodigo}. El funcionamiento es muy similar al método anterior pero simplificado y eliminando el uso de la anterior biblioteca.



\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/08.detect_zone_codigo.png}
	\caption{Código de la clase DetectZone que gestiona cada zona de detección.}
	\label{fig:detectZoneCodigo}
\end{figure}




De esta manera termina la migración desde HTC Vive y VRTK a Meta Quest 2 y su SDK de interacción. Este cambio se ha hecho para favorecer la facilidad de uso del juego gracias a eliminar la necesidad de cables y al uso de la tecnología de seguimiento de manos de Meta, así como la modernización y actualización de software y dispositivos con mayor soporte y vida útil en el futuro.


\subsubsection{Uniendo y completando el proyecto}

En este apartado se va a detallar el trabajo realizado para unir todas las pruebas desarrolladas anteriormente creando un flujo de juego completo y repetible. En las anteriores entregas se han ido desarrollando funcionalidades según las necesidades puntuales para alcanzar el objetivo de cada una de ellas, pero llegado este punto es necesario adquirir una visión completa del proyecto y plantear un buen diseño de clases que permitan una buena funcionalidad sin crear problemas o incompatibilidades en el futuro. 

Se ha creado un diseño basado en dividir responsabilidades y asignar cada una su respectiva clase manager, por ejemplo, la clase UIManger se encarga de todo lo relacionado con la interfaz de usuario (UI, User Interface en inglés). A su vez, todas estas clases manager se comunican con la clase GameManager, que es la que controla todo el flujo y realiza las llamadas al resto de managers. También existe la clase Prueba, creada para agrupar las funciones comunes y de la que heredan las clases concretas para cada prueba. A parte de estas clases, también existen clases más especificas para controlar aspectos concreto como el movimiento de los ascensores o la interacción de los objetos en las zonas de detección.

\paragraph{Game Manager}

Esta es la clase principal que controla el flujo del juego. Cuando la aplicación arranca, busca y guarda las instancias del resto de managers y da la señal al UIManager de que muestre los mensajes de tutorial y bienvenida. Más adelante se encargará también de hacer que el PruebasManager comience la prueba en el momento adecuado, llevar la cuenta del numero de pruebas realizadas o coordinar la interfaz de usuario con el gestor de las pruebas. 

Contiene métodos para comenzar y terminar las pruebas (llamando también a los otros managers), saltar pruebas, elegir las posibilidades que se le mostrarán al usuario (véase figura \ref{fig:gmDiagrama}) y también se encarga de controlar en todo momento el estado en el que se encuentra el juego. De esta forma puede llevar a cabo diferentes acciones dependiento del estado actual. Estos estados cambian según el grafo de la figura \ref{fig:grafoEstados}, se definen en un enumerable llamado EstadoJuego, y son los siguientes:

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/11.game_manager_diagrama.png}
	\caption{Diagrama de la clase GameManager.}
	\label{fig:gmDiagrama}
\end{figure}


\begin{itemize}
	\item {\textbf{Arrancado}. Mientras el juego está preparando todo lo necesario después de iniciarlo.}
	\item {\textbf{Tutorial}. El juego está mostrando su tutorial al jugador.}
	\item {\textbf{Listo}. Estado base del juego, se muestra la pantalla principal en el escenario.}
	\item {\textbf{EleccionPrueba}. El jugador está eligiendo qué prueba realizar.}
	\item {\textbf{Prueba}. La prueba está en curso.}
	\item {\textbf{FinPrueba}. El jugador ha superado la prueba y puede continuar el juego.}
	\item {\textbf{Final}. Tras superar todas las pruebas, el juego ha terminado. El jugador puede reiniciar si así lo desea.}
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/10.grafo_estados.png}
	\caption{Grafo dirigido de los posibles cambios de estado durante el juego.}
	\label{fig:grafoEstados}
\end{figure}




\paragraph{UI Manager}
Esta clase se encarga de gestionar todo lo relacionado con la interfaz de usuario. En este caso, la UI se muestra siempre en la pantalla gigante del escenario y el usuario puede interactuar con los botones de ella mediante rayos. Cuando comienza el juego, muestra el tutorial y se mantiene a la espera de que el usuario pulse el botón de continuar, en ese momento, actualiza la pantalla para mostrar la pantalla principal. En la fase de elección de pruebas, muestra los botones para que el usuario elija, y durante la fase de prueba puede mostrar un mensaje personalizado para cada una.

\paragraph{Pruebas Manager}

\paragraph{Escenario Manager}

\paragraph{Trigger Manager}

\paragraph{Detect Manager}









\subsubsection{Interacciones entre clases}

\subsubsection{Diagrama final de clases}

A continuación, en la figura \ref{fig:diagramaClases} se muestra el diagrama de clases completo desarrollado para este proyecto.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.5\textwidth, angle=-90]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/09.diagrama_clases.png}
	\caption{Diagrama de las clases desarrolladas para este proyecto.}
	\label{fig:diagramaClases}
\end{figure}






