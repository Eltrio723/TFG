
\subsection{Iteración 1}

El objetivo inicial de esta entrega era el de diseñar y crear todo el flujo que seguirá el juego. Teniendo en cuenta de que se pretende recrear un concurso televisivo, se va desarrollar una introducción que describa el concurso y presente las reglas al jugador, además de las fases que ocurrirán al principio y final de cada prueba, así como entre cada una de ellas. Finalmente, se añadirá un menú en el que se podrán cambiar los ajustes del juego, entre ellos: la dificultad, los tipos de pruebas que aparecerán, si el jugador está sentado o de pie, o si el jugador tendrá ayuda de una persona externa o no.

Este objetivo se ha visto alterado por pasar a disponer de un nuevo dispositivo de RV para el desarrollo, en este caso las gafas Meta Quest 2. Como se explica en la sección \textbf{Tecnología a usar} (\ref{sec:tecnologiaUsar}), este dispositivo es mucho más deseable para este proyecto, ya que permite prescindir de un ordenador externo al que conectar las gafas, del uso de estaciones base separadas para realizar el seguimiento del casco y los mandos, y al ser más reciente permite utilizar las bibliotecas más modernas para facilitar el desarrollo. Por estas razones, aún suponiendo un extra de carga de trabajo, se decide realizar el cambio de dispositivo, el cual se describe a continuación.


\subsubsection{Migración dispositivo VR}

El primer paso es crear una copia de seguridad en caso de haber alguna incompatibilidad. A continuación, se descarga la última versión del editor de Unity, en este caso se usará la versión 2023.1.9f1. Una vez instalada, abrimos el proyecto usando la nueva versión. Durante la migración de una versión a otra aparecen errores de y se recibe el aviso de que el proyecto puede no funcionar. Cuando se abre el proyecto aparece un nuevo aviso sobre varios paquetes que están obsoletos (\ref{fig:deprecated})




\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/03.deprecated.png}
	\caption{Aviso sobre paquetes obsoletos.}
	\label{fig:deprecated}
\end{figure}


Tras desinstalar los paquetes obsoletos, en este caso tanto SteamVR, Zinnia y VRTK, se va a proceder a instalar las nuevas bibliotecas para Meta Quest 2, para ello se va a seguir la documentación oficial. \cite{DES_5_1_oculusSDK} El proceso a seguir es sencillo y consiste en importar el nuevo paquete OculusIntegration (versión 55 en este caso). No ha surgido ningún nuevo problema, la documentación es buena y muy visual, y un proceso similar ya se ha descrito en la \textbf{Entrega 1} (\ref{sec:Entrega1Iteracion1}), por lo que no voy a desarrollar mucho esta instalación.

Una vez instalada la nueva biblioteca, el siguiente paso es recuperar todas las funcionalidades que ya estaban desarrolladas para las HTC Vive anteriormente. Por suerte el SDK de integración de Oculus es muy completo y tiene ya implementado casi todo lo necesario. Usando el objeto OculusInteractionSampleRig (figura \ref{fig:sample_rig}), podemos añadir a la escena tanto la cámara como los controladores y todo lo necesario para el seguimiento y la interacción básica con el juego.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/04.sample_rig.png}
	\caption{Jerarquía del objeto OculusInteractionSampleRig incluido con el SDK de Meta.}
	\label{fig:sample_rig}
\end{figure}


Para facilitar el uso del juego a personas con pocos conocimientos tecnológicos, se va a usar el seguimiento de manos proporcionado por el visor, de esta forma se proyecta en el juego una representación exacta de las manos de los usuarios y sus movimientos, como se puede ver en la figura \ref{fig:hand_tracking}.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/05.hand_tracking.png}
	\caption{Manos virtuales captadas usando el seguimiento de Meta Quest 2.}
	\label{fig:hand_tracking}
\end{figure}

A continuación es necesario añadir las posibles interacciones de las manos con el entorno, en este caso: coger y pulsar objetos y poder seleccionar elementos lejanos mediante un rayo. De nuevo, el SDK proporciona elementos ya configurados para estos casos. Solo es necesario añadirlos a la jerarquía según la figura \ref{fig:interactors}. En este caso se añaden tanto para las manos como para los mandos, en caso de desear utilizarlos.


\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/06.interactors.png}
	\caption{\textit{Interactors} que permiten coger, pulsar o lanzar rayos.}
	\label{fig:interactors}
\end{figure}

Finalmente, para que un objeto del juego pueda interactuar con el jugador, necesita nuevos scripts también proporcionados por el SDK, en este caso son: 

♠\begin{itemize}
	\item {\textit{Grabbable}: Permite que un objeto pueda ser cogido y define su comportamiento.}
	\item{\textit{Grab Interactable}: Permite que el elemento sea cogido con los mandos.}
	\item{\textit{Hand Grab Interactable}: Permite que el elemento sea cogido con las manos.}
	\item{\textit{Ray Interactable}: Permite lanzar un rayo sobre el objeto para interactuar con él.}
\end{itemize}


Tras estos pasos, la migración queda terminada y podemos comenzar a utilizar Meta Quest 2 y su seguimiento de manos en el proyecto. Aunque aún es necesario cambiar el funcionamiento de varias pruebas debido a cambios en las nuevas bibliotecas.


En concreto es necesario actualizar las zonas de \textit{snap} utilizadas en las pruebas de asociación, donde el jugador debe coger y colocar en plataformas distintos objetos, agrupándolos por categorías. Lo que se ha decidido hacer es reemplazar este sistema por otro más sencillo en el que un \textit{trigger} sobre la plataforma detecta los objetos que se introducen en él (figura \ref{fig:detectZone}), comprobando si tienen o no la categoría deseada. 


\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/07.detect_zone.png}
	\caption{Zona de detección formada por un \textit{trigger} sobre una plataforma.}
	\label{fig:detectZone}
\end{figure}

Puesto que se usa el mismo método de detección para las dos posibles categorías, es necesario tener en cuenta de qué categoría es el objeto y si las dos zonas de detección contienen el mismo tipo de objeto. Esto se hace por medio de los métodos \textit{OnTriggerEnter} y \textit{OnTriggerExit}. También es necesario llevar la cuenta de cuantos objetos hay dentro del \textit{trigger}. Todo esto se hace como se muestra en la figura \ref{fig:detectZoneCodigo}. El funcionamiento es muy similar al método anterior pero simplificado y eliminando el uso de la anterior biblioteca.



\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/08.detect_zone_codigo.png}
	\caption{Código de la clase DetectZone que gestiona cada zona de detección.}
	\label{fig:detectZoneCodigo}
\end{figure}




De esta manera termina la migración desde HTC Vive y VRTK a Meta Quest 2 y su SDK de interacción. Este cambio se ha hecho para favorecer la facilidad de uso del juego gracias a eliminar la necesidad de cables y al uso de la tecnología de seguimiento de manos de Meta, así como la modernización y actualización de software y dispositivos con mayor soporte y vida útil en el futuro.


\subsubsection{Uniendo y completando el proyecto}

En este apartado se va a detallar el trabajo realizado para unir todas las pruebas desarrolladas anteriormente creando un flujo de juego completo y repetible. En las anteriores entregas se han ido desarrollando funcionalidades según las necesidades puntuales para alcanzar el objetivo de cada una de ellas, pero llegado este punto es necesario adquirir una visión completa del proyecto y plantear un buen diseño de clases que permitan una buena funcionalidad sin crear problemas o incompatibilidades en el futuro. 

Se ha creado un diseño basado en dividir responsabilidades y asignar cada una su respectiva clase manager, por ejemplo, la clase UIManger se encarga de todo lo relacionado con la interfaz de usuario (UI, User Interface en inglés). A su vez, todas estas clases manager se comunican con la clase GameManager, que es la que controla todo el flujo y realiza las llamadas al resto de managers. También existe la clase Prueba, creada para agrupar las funciones comunes y de la que heredan las clases concretas para cada prueba. A parte de estas clases, también existen clases más especificas para controlar aspectos concreto como el movimiento de los ascensores o la interacción de los objetos en las zonas de detección.

\paragraph{Game Manager}

Esta es la clase principal que controla el flujo del juego. Cuando la aplicación arranca, busca y guarda las instancias del resto de managers y da la señal al UIManager de que muestre los mensajes de tutorial y bienvenida. Más adelante se encargará también de hacer que el PruebasManager comience la prueba en el momento adecuado, llevar la cuenta del numero de pruebas realizadas o coordinar la interfaz de usuario con el gestor de las pruebas. 

Contiene métodos para comenzar y terminar las pruebas (llamando también a los otros managers), saltar pruebas, elegir las posibilidades que se le mostrarán al usuario (véase figura \ref{fig:gmDiagrama}) y también se encarga de controlar en todo momento el estado en el que se encuentra el juego. De esta forma puede llevar a cabo diferentes acciones dependiento del estado actual. Estos estados cambian según el grafo de la figura \ref{fig:grafoEstados}, se definen en un enumerable llamado EstadoJuego, y son los siguientes:

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/11.game_manager_diagrama.png}
	\caption{Diagrama de la clase GameManager.}
	\label{fig:gmDiagrama}
\end{figure}


\begin{itemize}
	\item {\textbf{Arrancado}. Mientras el juego está preparando todo lo necesario después de iniciarlo.}
	\item {\textbf{Tutorial}. El juego está mostrando su tutorial al jugador.}
	\item {\textbf{Listo}. Estado base del juego, se muestra la pantalla principal en el escenario.}
	\item {\textbf{EleccionPrueba}. El jugador está eligiendo qué prueba realizar.}
	\item {\textbf{Prueba}. La prueba está en curso.}
	\item {\textbf{FinPrueba}. El jugador ha superado la prueba y puede continuar el juego.}
	\item {\textbf{Final}. Tras superar todas las pruebas, el juego ha terminado. El jugador puede reiniciar si así lo desea.}
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/10.grafo_estados.png}
	\caption{Grafo dirigido de los posibles cambios de estado durante el juego.}
	\label{fig:grafoEstados}
\end{figure}




\paragraph{UI Manager}
Esta clase se encarga de gestionar todo lo relacionado con la interfaz de usuario. En este caso, la UI se muestra siempre en la pantalla gigante del escenario y el usuario puede interactuar con los botones de ella mediante rayos. Cuando comienza el juego, muestra el tutorial y se mantiene a la espera de que el usuario pulse el botón de continuar, en ese momento, actualiza la pantalla para mostrar la pantalla principal. En la fase de elección de pruebas, muestra los botones para que el usuario elija (figura \ref{fig:uiManagerCodigo}), y durante la fase de prueba puede mostrar un mensaje personalizado para cada una. Esta clase controla todos los botones que aparecen en el juego, y al pulsarlos realiza las acciones necesarias, como llamar al GameManager para avanzar de fase, o al PruebasManager para comprobar si una respuesta es correcta. 

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/12.ui_manager_mostrar_botones.png}
	\caption{Código de la clase UIManager. Método para terminar el tutorial pulsando el botón de 'Entendido' y método para cargar los botones de elección de pruebas.}
	\label{fig:uiManagerCodigo}
\end{figure}


En el diagrama de clase de la figura \ref{fig:diagramaUI} se muestra como esta clase contiene una referencia a todos los elementos de la interfaz de usuario y los métodos para cambiar la pantalla dependiendo de la fase de juego actual, como PantallaEleccion() o PantallaFinPrueba().

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/13.diagrama_ui.png}
	\caption{Diagrama de clase para UIManager.}
	\label{fig:diagramaUI}
\end{figure}



\paragraph{Pruebas Manager}
Este controlador se encarga de gestionar todo lo referente a las pruebas que se realizan en el juego. Contiene una referencia a una instancia de cada tipo de prueba (atributos con prefijo 'Prefab' en la figura \ref{fig:diagramaPruebasManager}), y se comunica con el GameManager para crear, comenzar y terminar las pruebas, así como con el EscenarioManager que dependiendo del tipo de prueba deberá adecuar el escenario como se verá a continuación. En todo momento, este manager contiene una referencia a la prueba que se está realizando y puede comprobar periódicamente si la prueba ha sido completada correctamente con el método CheckPruebaCorrecta().

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/14.diagrama_pruebas_manager.png}
	\caption{Diagrama de clase para PruebasManager.}
	\label{fig:diagramaPruebasManager}
\end{figure}



\paragraph{Escenario Manager}
Esta clase se encarga de realizar los cambios de escenario durante el juego. Estos cambios son principalmente bajar el ascensor que haya en el momento, crear uno nuevo adecuado a la prueba que se vaya a realizar, incluyendo todos los objetos necesarios para ella, y elevarlo de nuevo a la posición superior frente al jugador. Además, como se puede ver en el diagrama de la figura \ref{fig:diagramaEscenarioManager}, también se encarga de instanciar, mostrar y destuir las imaágenes y sonidos utilizados en algunas pruebas, y especialmente se comunica con el TriggerManager y el DetectManager ya que estas funciones de las pruebas forman parte del escenario.

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/15.diagrama_escenario.png}
	\caption{Diagrama de clase para EscenarioManager.}
	\label{fig:diagramaEscenarioManager}
\end{figure}


\paragraph{Trigger Manager}
Esta clase se utiliza en las pruebas de baile y de posiciones. En estas pruebas, el jugador debe seguir unas indicaciones y colocar los brazos en varias posiciones. Este funcionamiento se explica en más profundidad en la Iteración 2 de la entrega 2 (sección \ref{E2_triggers}).

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/16.diagrama_trigger_manager.png}
	\caption{Diagrama de clase para TriggerManager.}
	\label{fig:diagramaTriggerManager}
\end{figure}


\paragraph{Detect Manager}





\paragraph{Ascensor}
Esta clase la tienen cada uno de los distintos ascensores que hay en el juego, uno por cada prueba. Su cometido es indicar si el ascensor se encuentra en su posición baja o elevada y hacer que transicione de una a otra de forma suave. 

Para hacer dicho movimiento se utiliza un método asíncrono que en Unity se denominan \textit{Coroutines} para hacer que en cada fotograma del juego avance ligeramente hacia su nueva posición. Cualquier movimiento asociado a la velocidad de fotogramas puede cambiar completamente cuando el juego se ejecuta a otra velocidad de la prevista, por ejemplo si el dispositivo de juego es más potente de lo esperado, o todo lo contrario, si el dispositivo no puede mantener una velocidad estable. 

Para evitar este problema se utiliza el valor interno de Unity llamado 'Time.deltaTime' que contiene para cada fotograma el tiempo en milisegundos que ha pasado desde el anterior fotograma, multiplicando la velocidad de movimiento por este valor como se muestra en la figura \ref{fig:ascensorBajar} se puede conseguir que este movimiento sea independiente. 

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/17.ascensor_bajar.png}
	\caption{Método asíncrono que baja el ascensor en cada fotograma.}
	\label{fig:ascensorBajar}
\end{figure}



\paragraph{Prueba}
Esta clase contiene todos los elementos necesarios para los distintos tipos de pruebas. Se ha elegido crear una estructura de herencia, donde cada tipo de prueba tiene su propia clase que hereda de esta. Esto es porque cada prueba tiene sus propias características, como las imágenes a mostrar, los sonidos a reproducir, los objetos que mostrar y especialmente cada una tiene su propia condición de victoria. Por esto, cada clase hija sobrescribe los métodos PrepararDatos() y CheckCorrecto() (véase figura \ref{fig:diagramaPruebas}).

En la figura \ref{fig:checkCorrecto} se muestra el método sobreescrito con el que la clase PruebaAsociacion utiliza el manager de detección para comprobar si los objetos han sido colocados en el lugar correcto (figura \ref{fig:detectCorrecto}).


\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/18.diagrama_pruebas.png}
	\caption{Diagrama de la clase Prueba y sus clases herederas.}
	\label{fig:diagramaPruebas}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/19.check_correcto.png}
	\caption{Método sobrescrito para comprobar si la prueba de asociaciones es correcta.}
	\label{fig:checkCorrecto}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/20.detect_correcto.png}
	\caption{Método de la clase DetectManager para comprobar si las zonas de detección contienen los objetos correctos.}
	\label{fig:detectCorrecto}
\end{figure}






\subsubsection{Interacciones entre clases}

\subsubsection{Diagrama final de clases}

A continuación, en la figura \ref{fig:diagramaClases} se muestra el diagrama de clases completo desarrollado para este proyecto. Este diagrama ha sido generado de forma automática mediante Visual Studio 2022. En este diagrama no aparecen las líneas de unión entre clases, ya que a pesar de que existen referencias entre ellas, debido al funcionamiento de Unity, las referencias no son directas entre clases, si no que son con objetos de tipo GameObject, que a su vez contiene dicha clase como uno de sus componentes. En Unity todos los elementos del juego son GameObjects, con distintos componenetes que serían las clases. A pesar de esto, los nombres que se usan son claros para evitar confusiones respecto al tipo de clase que contienen.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.5\textwidth, angle=-90]{04.Desarrollo/05.Entrega5/01.Iteracion5_1/00.Figuras/09.diagrama_clases.png}
	\caption{Diagrama de las clases desarrolladas para este proyecto.}
	\label{fig:diagramaClases}
\end{figure}






